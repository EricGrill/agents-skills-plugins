import type { Backend } from "../backends/interface.js";
import type { ToolDefinition } from "../server.js";

function createToolRunner(
  backend: Backend,
  instanceIdArg: string,
  buildCommand: (args: Record<string, unknown>) => string[],
  timeoutMs = 300000
) {
  return async (args: Record<string, unknown>) => {
    const instanceId = args[instanceIdArg] as string;
    const command = buildCommand(args);

    const result = await backend.execCommand(instanceId, command, {
      user: "root",
      timeoutMs,
    });

    return {
      content: [
        {
          type: "text" as const,
          text: JSON.stringify(
            {
              success: result.exitCode === 0,
              exit_code: result.exitCode,
              stdout: result.stdout,
              stderr: result.stderr,
            },
            null,
            2
          ),
        },
      ],
    };
  };
}

export function registerExploitTools(
  backend: Backend,
  tools: Map<string, ToolDefinition>
): void {
  // metasploit_search - Search for exploits/modules
  tools.set("metasploit_search", {
    name: "metasploit_search",
    description: "Search Metasploit modules by keyword.",
    inputSchema: {
      type: "object",
      properties: {
        instance_id: { type: "string", description: "Kali instance ID" },
        query: {
          type: "string",
          description: "Search query (e.g., 'smb', 'apache')",
        },
        type: {
          type: "string",
          enum: ["exploit", "auxiliary", "post", "payload"],
          description: "Module type to search",
        },
      },
      required: ["instance_id", "query"],
    },
    handler: createToolRunner(backend, "instance_id", (args) => {
      let searchTerm = args.query as string;
      if (args.type) {
        searchTerm = `type:${args.type} ${searchTerm}`;
      }
      return ["msfconsole", "-q", "-x", `search ${searchTerm}; exit`];
    }),
  });

  // metasploit_run - Run a Metasploit module
  tools.set("metasploit_run", {
    name: "metasploit_run",
    description:
      "Run a Metasploit module with specified options. Use metasploit_search first to find modules.",
    inputSchema: {
      type: "object",
      properties: {
        instance_id: { type: "string", description: "Kali instance ID" },
        module: {
          type: "string",
          description: "Module path (e.g., 'exploit/windows/smb/ms17_010_eternalblue')",
        },
        options: {
          type: "object",
          description: "Module options as key-value pairs (e.g., {RHOSTS: '192.168.1.1'})",
        },
        payload: {
          type: "string",
          description: "Payload to use (e.g., 'windows/x64/meterpreter/reverse_tcp')",
        },
        check_only: {
          type: "boolean",
          description: "Only check if target is vulnerable, don't exploit",
        },
      },
      required: ["instance_id", "module"],
    },
    handler: createToolRunner(
      backend,
      "instance_id",
      (args) => {
        const commands: string[] = [`use ${args.module}`];

        const options = args.options as Record<string, string> | undefined;
        if (options) {
          for (const [key, value] of Object.entries(options)) {
            commands.push(`set ${key} ${value}`);
          }
        }

        if (args.payload) {
          commands.push(`set PAYLOAD ${args.payload}`);
        }

        if (args.check_only) {
          commands.push("check");
        } else {
          commands.push("run");
        }

        commands.push("exit");

        return ["msfconsole", "-q", "-x", commands.join("; ")];
      },
      1800000 // 30 min for exploits
    ),
  });

  // searchsploit_search - Search Exploit-DB
  tools.set("searchsploit_search", {
    name: "searchsploit_search",
    description: "Search Exploit-DB offline database for exploits.",
    inputSchema: {
      type: "object",
      properties: {
        instance_id: { type: "string", description: "Kali instance ID" },
        query: { type: "string", description: "Search query" },
        json: { type: "boolean", description: "Output in JSON format" },
      },
      required: ["instance_id", "query"],
    },
    handler: createToolRunner(backend, "instance_id", (args) => {
      const cmd = ["searchsploit"];
      if (args.json) cmd.push("-j");
      cmd.push(args.query as string);
      return cmd;
    }),
  });

  // msfvenom_generate - Generate payloads
  tools.set("msfvenom_generate", {
    name: "msfvenom_generate",
    description: "Generate payloads using msfvenom.",
    inputSchema: {
      type: "object",
      properties: {
        instance_id: { type: "string", description: "Kali instance ID" },
        payload: {
          type: "string",
          description: "Payload type (e.g., 'windows/x64/meterpreter/reverse_tcp')",
        },
        format: {
          type: "string",
          description: "Output format (exe, elf, raw, python, etc.)",
        },
        lhost: { type: "string", description: "Listener host IP" },
        lport: { type: "number", description: "Listener port" },
        output: {
          type: "string",
          description: "Output file path (in container)",
        },
        encoder: {
          type: "string",
          description: "Encoder to use (e.g., 'x86/shikata_ga_nai')",
        },
        iterations: {
          type: "number",
          description: "Number of encoding iterations",
        },
      },
      required: ["instance_id", "payload", "format"],
    },
    handler: createToolRunner(backend, "instance_id", (args) => {
      const cmd = [
        "msfvenom",
        "-p",
        args.payload as string,
        "-f",
        args.format as string,
      ];
      if (args.lhost) cmd.push(`LHOST=${args.lhost}`);
      if (args.lport) cmd.push(`LPORT=${args.lport}`);
      if (args.encoder) cmd.push("-e", args.encoder as string);
      if (args.iterations) cmd.push("-i", String(args.iterations));
      if (args.output) {
        cmd.push("-o", args.output as string);
      }
      return cmd;
    }),
  });
}
